Here is your **GitHub-friendly markdown version** of your blog post **“Scaling DevSecOps with Kubernetes: Zero Downtime, Auto Healing, and More”**, with all images and Hashnode extras removed — but preserving **clean formatting, headings, code blocks, and structure**.

---

````markdown
# 🚀 Scaling DevSecOps with Kubernetes: Zero Downtime, Auto Healing, and More

**Author:** Bhavya Pasupuleti  
📅 **Published:** Jun 12, 2025  
🕒 **Reading Time:** ~15 min  

---

## 📌 Introduction

In this third phase of our DevSecOps journey, we move from a Docker-only setup to a **production-ready Kubernetes environment** with:

- ⏱️ Zero Downtime deployments  
- 🔁 Rollbacks on failure  
- 📈 Auto Scaling  
- ❤️ Self-Healing containers  

We’ll walk through:

✅ Kubernetes Basics  
✅ EKS Setup (AWS Managed K8s)  
✅ YAML Definitions  
✅ Jenkins Integration  
✅ GitOps with Argo CD

---

## 🔧 Step 1: Launch EC2 for Jenkins & Tooling

- **AMI:** Amazon Linux 2  
- **Instance Type:** t2.large  
- **Storage:** 25 GB  
- **IAM Role:** EC2, S3, EKS Full Access  
- **Security Group:** Port 22 (SSH) open

---

## 🛠️ Step 2: Install DevSecOps Tech Stack

```bash
# Git
yum install git -y

# Jenkins
wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key
yum install java-17-amazon-corretto jenkins -y
systemctl start jenkins && systemctl enable jenkins

# Docker
yum install docker -y
systemctl start docker && systemctl enable docker
chmod 777 /var/run/docker.sock

# Terraform
sudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/AmazonLinux/hashicorp.repo
yum install terraform -y

# SonarQube (Docker)
docker run -itd --name sonar -p 9000:9000 sonarqube:lts-community

# Trivy
wget https://github.com/aquasecurity/trivy/releases/download/v0.18.3/trivy_0.18.3_Linux-64bit.tar.gz
tar zxvf trivy_0.18.3_Linux-64bit.tar.gz
sudo mv trivy /usr/local/bin/

# AWS CLI v2
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install

# kubectl
curl -LO "https://dl.k8s.io/release/v1.32.0/bin/linux/amd64/kubectl"
chmod +x kubectl && sudo mv kubectl /usr/local/bin/

# eksctl
curl -sLO "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_Linux_amd64.tar.gz"
tar -zxvf eksctl_Linux_amd64.tar.gz
sudo mv eksctl /usr/local/bin/
````

---

## ☁️ Step 3: Provision EKS Using Terraform

```bash
git clone https://github.com/PasupuletiBhavya/devsecops-project.git
cd devsecops-project/k8s-project/eks-terraform

terraform init
terraform plan
terraform apply --auto-approve
```

---

## 🔗 Step 4: Connect kubectl to EKS

```bash
aws eks update-kubeconfig --region us-east-1 --name EKS_CLOUD
kubectl get nodes
```

---

## 🧠 Setup Recap

* **Ops Server (Jenkins EC2):** Controls build/test/deploy
* **Pre-Prod (EKS\_CLOUD):** Hosts UAT & Staging via namespaces

---

## 🧪 Step 5: Jenkins UAT Build Pipeline

```groovy
pipeline {
    agent any
    tools {
        nodejs 'node16'
    }
    environment {
        SCANNER_HOME = tool 'mysonar'
    }
    stages {
        stage('CODE') {
            steps { git "https://github.com/PasupuletiBhavya/devsecops-project.git" }
        }
        stage('CQA') {
            steps {
                withSonarQubeEnv('mysonar') {
                    sh '''
                        $SCANNER_HOME/bin/sonar-scanner \
                        -Dsonar.projectName=camp \
                        -Dsonar.projectKey=camp
                    '''
                }
            }
        }
        stage('QualityGates') {
            steps {
                waitForQualityGate abortPipeline: false, credentialsId: 'sonar'
            }
        }
        stage('NPM Test') { steps { sh 'npm install' } }
        stage('Docker Build') {
            steps { sh 'docker build -t bhavyap007/finalround:UAT-v1 .' }
        }
        stage('Trivy Scan') {
            steps { sh 'trivy image bhavyap007/finalround:UAT-v1' }
        }
        stage('Push Image') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'dockerhub') {
                        sh 'docker push bhavyap007/finalround:UAT-v1'
                    }
                }
            }
        }
    }
    post {
        always {
            slackSend (
                channel: 'all-camp',
                message: "*${currentBuild.currentResult}:* Job ${env.JOB_NAME} \nBuild: ${env.BUILD_NUMBER} \nDetails: ${env.BUILD_URL}"
            )
        }
    }
}
```

---

## 🔐 Step 6: Kubernetes Access for Jenkins

1. Create `service-account.yml` for namespace `uat`
2. Define `role.yml` with access rules
3. Bind using `rolebinding.yml`
4. Create `secret.yml` and fetch token via:

```bash
kubectl describe secret mysecretname -n uat
```

Use this token in Jenkins (credentials → Secret Text)

---

## 🚀 Jenkins UAT Deploy Pipeline

```groovy
pipeline {
    agent any
    environment {
        NAMESPACE = "uat"
    }
    stages {
        stage('Checkout Code') {
            steps { git 'https://github.com/PasupuletiBhavya/devsecops-project.git' }
        }
        stage('Deploy to Kubernetes') {
            steps {
                withKubeCredentials(kubectlCredentials: [[
                    credentialsId: 'k8s-token',
                    namespace: "${NAMESPACE}",
                    serverUrl: 'https://<your-eks-endpoint>'
                ]]) {
                    sh "kubectl apply -f Manifests -n ${NAMESPACE}"
                }
            }
        }
        stage('Verify Deployment') {
            steps {
                sh "kubectl get all -n ${NAMESPACE}"
                sh "sleep 30"
            }
        }
    }
    post {
        always {
            slackSend (
                channel: 'all-camp',
                message: "*${currentBuild.currentResult}:* Job `${env.JOB_NAME}`\nBuild `${env.BUILD_NUMBER}`\nMore info: ${env.BUILD_URL}"
            )
        }
    }
}
```

---

## 🌐 Step 7: Staging & Production Pipelines

* Duplicate UAT pipeline
* Replace:

  * `uat` → `staging` or `prod`
  * Docker tag
  * Token ID
  * Namespace in YAML files

Use **separate EKS clusters** for production (EKS\_CLOUD\_PROD)

---

## 🔄 Step 8: Install Argo CD with Helm

```bash
# Install Helm
curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
chmod 700 get_helm.sh && ./get_helm.sh

# Argo CD setup
helm repo add argo-cd https://argoproj.github.io/argo-helm
helm repo update
kubectl create namespace argocd
helm install argocd argo-cd/argo-cd -n argocd

# Expose Argo CD via LoadBalancer
kubectl patch svc argocd-server -n argocd -p '{"spec": {"type": "LoadBalancer"}}'

# Get LoadBalancer URL
kubectl get svc argocd-server -n argocd -o json | jq -r .status.loadBalancer.ingress[0].hostname

# Get admin password
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d
```

---

## 🧹 Step 9: Clean Up (Avoid Billing)

```bash
terraform destroy --auto-approve
aws eks update-kubeconfig --region us-east-1 --name EKS_CLOUD
terraform workspace select default
terraform destroy --auto-approve
```

---

## 🏁 Final Architecture

* **EKS\_CLOUD:** UAT + Staging (namespaces)
* **EKS\_CLOUD\_PROD:** Production-only
* GitOps with ArgoCD
* Slack integrated for visibility

---

## 💡 What I Learned

✅ Built a secure, production-grade DevSecOps pipeline
✅ Automated CI/CD with Jenkins, Docker, Trivy, SonarQube
✅ Deployed across isolated environments with Terraform & EKS
✅ Introduced GitOps with Argo CD for Production
✅ Improved observability and rollback options

---

Let’s connect on [LinkedIn](https://www.linkedin.com/in/bhavyapasupuleti)!
Feel free to ⭐ this repo if you found it useful 🙌

```

---

✅ **Next Steps:**

- Paste this into your GitHub README.
- Add relevant images under `/assets/` folder and link using relative paths if needed.
- Push to GitHub with proper commit message like `docs: add Kubernetes DevSecOps blog`.

Let me know if you want the images section added too or if you'd like a separate `README.md` file download link.
```
