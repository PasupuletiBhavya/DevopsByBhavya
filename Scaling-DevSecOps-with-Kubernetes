# Scaling DevSecOps with Kubernetes: Zero Downtime, Auto Healing, and More

## Introduction

In this third phase of our DevSecOps journey, we move from Docker-only deployment to a robust Kubernetes setup. Kubernetes enables:

* Zero Downtime during updates
* Rollbacks on failure
* Auto Scaling
* Self-Healing containers

Weâ€™ll cover:

* Kubernetes Basics
* Deployment Strategies
* EKS Setup on AWS
* Writing YAMLs
* Final Production Push

---

## Step 1: Launch EC2 Instance

* AMI: Amazon Linux 2 (Kernel 5.10)
* Instance Type: t2.large
* Storage: 25 GB EBS
* Key Pair: Existing or new
* IAM Role: EC2, S3, EKS full access
* Security Group: Port 22 open

---

## Step 2: Install DevSecOps Tech Stack

### Git

```bash
yum install git -y
```

### Jenkins

```bash
sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo
sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io-2023.key
yum install java-17-amazon-corretto -y
yum install jenkins -y
systemctl start jenkins
systemctl enable jenkins
systemctl status jenkins
```

### Docker

```bash
yum install docker -y
systemctl start docker
systemctl enable docker
systemctl status docker
chmod 777 /var/run/docker.sock
```

### Terraform

```bash
sudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/AmazonLinux/hashicorp.repo
sudo yum install terraform -y
```

### SonarQube (Docker)

```bash
docker run -itd --name sonar -p 9000:9000 sonarqube:lts-community
```

### Trivy

```bash
wget https://github.com/aquasecurity/trivy/releases/download/v0.18.3/trivy_0.18.3_Linux-64bit.tar.gz
tar zxvf trivy_0.18.3_Linux-64bit.tar.gz
sudo mv trivy /usr/local/bin/
```

### AWS CLI v2

```bash
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
sudo ./aws/install
```

### kubectl

```bash
curl -LO "https://dl.k8s.io/release/v1.32.0/bin/linux/amd64/kubectl"
chmod +x kubectl
sudo mv kubectl /usr/local/bin/
kubectl version --client
```

### eksctl

```bash
curl --silent --location "https://github.com/eksctl-io/eksctl/releases/latest/download/eksctl_Linux_amd64.tar.gz" -o eksctl.tar.gz
tar -zxvf eksctl.tar.gz
sudo mv eksctl /usr/local/bin/
eksctl version
```

---

## Step 3: Provision EKS using Terraform

```bash
git clone https://github.com/PasupuletiBhavya/devsecops-project.git
cd k8s-project/eks-terraform
```

Update `backend.tf`, `provider.tf`, `main.tf` with:

```hcl
terraform init
terraform plan
terraform apply --auto-approve
```

---

## Step 4: Connect to EKS

```bash
eksctl get cluster --region us-east-1
aws eks update-kubeconfig --region us-east-1 --name EKS_CLOUD
kubectl get nodes
```

---

## Jenkins Server vs Worker Node

* Jenkins EC2 = control center for pipeline automation
* EKS Worker Node = hosts app containers

---

## CI/CD Pipeline (UAT)

### Jenkinsfile (UAT Build)

```groovy
pipeline {
    agent any
    tools { nodejs 'node16' }
    environment { SCANNER_HOME = tool 'mysonar' }
    stages {
        stage('CODE') {
            steps { git "https://github.com/PasupuletiBhavya/devsecops-project.git" }
        }
        stage('CQA') {
            steps {
                withSonarQubeEnv('mysonar') {
                    sh '''
                        $SCANNER_HOME/bin/sonar-scanner \
                        -Dsonar.projectName=camp \
                        -Dsonar.projectKey=camp
                    '''
                }
            }
        }
        stage('QualityGates') {
            steps { waitForQualityGate abortPipeline: false, credentialsId: 'sonar' }
        }
        stage('NPM Test') {
            steps { sh 'npm install' }
        }
        stage('Docker Build') {
            steps { sh 'docker build -t bhavyap007/finalround:UAT-v1 .' }
        }
        stage('Trivy Scan') {
            steps { sh 'trivy image bhavyap007/finalround:UAT-v1' }
        }
        stage('Push Image') {
            steps {
                script {
                    withDockerRegistry(credentialsId: 'dockerhub') {
                        sh 'docker push bhavyap007/finalround:UAT-v1'
                    }
                }
            }
        }
    }
    post {
        always {
            slackSend (
                channel: 'all-camp',
                message: "*${currentBuild.currentResult}:* Job ${env.JOB_NAME} \nBuild: ${env.BUILD_NUMBER} \nDetails: ${env.BUILD_URL}"
            )
        }
    }
}
```

---

## Kubernetes Manifests for Jenkins Deployment

### service-account.yml

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: jenkins
  namespace: uat
```

### role.yml

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: app-role
  namespace: uat
rules:
  - apiGroups: ["", "apps", "autoscaling", "batch", "extensions", "policy", "rbac.authorization.k8s.io"]
    resources: ["pods", "services", "deployments", "secrets", "configmaps", "replicasets"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
```

### rolebinding.yml

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: app-rolebinding
  namespace: uat
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: app-role
subjects:
  - kind: ServiceAccount
    name: jenkins
    namespace: uat
```

### secret.yml

```yaml
apiVersion: v1
kind: Secret
type: kubernetes.io/service-account-token
metadata:
  name: mysecretname
  annotations:
    kubernetes.io/service-account.name: jenkins
```

Apply all:

```bash
kubectl create namespace uat
kubectl apply -f service-account.yml
kubectl apply -f role.yml
kubectl apply -f rolebinding.yml
kubectl apply -f secret.yml -n uat
```

Retrieve token:

```bash
kubectl describe secret mysecretname -n uat
```

Use in Jenkins: Add `Secret Text` with ID: `k8-token`

---

## Jenkins Deploy Pipeline (UAT)

```groovy
pipeline {
    agent any
    environment { NAMESPACE = "uat" }
    stages {
        stage('Checkout Code') {
            steps { git 'https://github.com/PasupuletiBhavya/devsecops-project.git' }
        }
        stage('Deploy to Kubernetes') {
            steps {
                withKubeCredentials(kubectlCredentials: [[
                    caCertificate: '',
                    clusterName: 'EKS_CLOUD',
                    contextName: 'myapp',
                    credentialsId: 'k8-token',
                    namespace: "${NAMESPACE}",
                    serverUrl: 'https://<eks-endpoint>'
                ]]) {
                    sh "kubectl apply -f Manifests -n ${NAMESPACE}"
                }
            }
        }
        stage('Verify Deployment') {
            steps {
                withKubeCredentials(kubectlCredentials: [[
                    caCertificate: '',
                    clusterName: 'EKS_CLOUD',
                    contextName: 'myapp',
                    credentialsId: 'k8-token',
                    namespace: "${NAMESPACE}",
                    serverUrl: 'https://<eks-endpoint>'
                ]]) {
                    sh "kubectl get all -n ${NAMESPACE}"
                    sh 'sleep 30'
                }
            }
        }
    }
    post {
        always {
            slackSend (
                channel: 'all-camp',
                message: "*${currentBuild.currentResult}:* Job `${env.JOB_NAME}`\nBuild `${env.BUILD_NUMBER}`\nMore info: ${env.BUILD_URL}"
            )
        }
    }
}
```

